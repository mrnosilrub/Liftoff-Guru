#!/usr/bin/env node
import fs from 'fs';
import fsp from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = process.cwd();

const IGNORED_DIR_NAMES = new Set([
  'node_modules', '.git', '.next', 'dist', 'build', '.cache', '.turbo', '.venv', '.pnpm-store', '.astro'
]);

const IGNORED_BASENAMES = new Set([
  'function.md', 'changelog.md', 'agents.md'
]);

const SCRIPT_RELATIVE_PATH = 'scripts/update-docs.mjs';

function toPosix(p) {
  return p.split(path.sep).join('/');
}

function rel(p) {
  const r = '/' + toPosix(path.relative(repoRoot, p));
  return r === '/'
    ? '/'
    : r;
}

function today() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const dd = String(d.getDate()).padStart(2, '0');
  return `${yyyy}-${mm}-${dd}`;
}

function isHidden(name) {
  return name.startsWith('.');
}

function describeDirectory(relativeDir) {
  const base = path.basename(relativeDir);
  if (relativeDir === '/') return 'Repository root overview and index of top-level files and folders.';
  switch (base) {
    case 'planning': return 'Planning documents for IA and early design.';
    case 'public': return 'Static assets that are copied as-is to the final build output.';
    case 'src': return 'Application source: pages, layouts, components, styles, content, and assets.';
    case 'assets': return 'Brand and shared assets referenced across the site.';
    case 'components': return 'Reusable UI components for pages and layouts.';
    case 'content': return 'Markdown/MDX content organized into collections.';
    case 'layouts': return 'Layout components that wrap page content and provide shared structure.';
    case 'pages': return 'Route files rendered by Astro.';
    case 'styles': return 'Global and shared stylesheets.';
    default: return `Overview of ${relativeDir} folder.`;
  }
}

function describeFile(base, dirRelative) {
  // Special names
  const specials = {
    'astro.config.mjs': 'Astro configuration.',
    'biome.json': 'Biome formatter/linter configuration.',
    'CNAME': 'Custom domain mapping for deployment.',
    'package.json': 'Project metadata, scripts, and dependencies.',
    'pnpm-lock.yaml': 'Dependency lockfile.',
    'tailwind.config.js': 'Tailwind CSS configuration.',
    'content.config.ts': 'Astro Content Collections configuration.'
  };
  if (Object.prototype.hasOwnProperty.call(specials, base)) return specials[base];

  const ext = path.extname(base).toLowerCase();
  if (ext === '.astro') {
    if (dirRelative.includes('/pages')) return 'Astro page route.';
    return 'Astro component.';
  }
  if (ext === '.md') return 'Markdown document.';
  if (ext === '.mdx') return 'MDX document/page.';
  if (ext === '.css') return 'Stylesheet.';
  if (ext === '.scss' || ext === '.sass') return 'Sass stylesheet.';
  if (ext === '.ts') return 'TypeScript module.';
  if (ext === '.tsx') return 'TypeScript React component/module.';
  if (ext === '.js') return 'JavaScript module.';
  if (ext === '.jsx') return 'React component/module.';
  if (ext === '.svg') return 'SVG vector asset.';
  if (['.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico'].includes(ext)) return 'Image/ico asset.';
  return 'File.';
}

async function readDirEntries(dir) {
  const all = await fsp.readdir(dir, { withFileTypes: true });
  const files = [];
  const dirs = [];
  for (const e of all) {
    if (isHidden(e.name) && e.name !== '.well-known') continue; // skip hidden except .well-known
    if (e.isDirectory()) {
      if (IGNORED_DIR_NAMES.has(e.name)) continue;
      dirs.push(e.name);
    } else if (e.isFile()) {
      if (IGNORED_BASENAMES.has(e.name)) continue;
      files.push(e.name);
    }
  }
  files.sort();
  dirs.sort();
  return { files, dirs };
}

function headerTitle(relativeDir) {
  return relativeDir === '/' ? 'Root folder overview' : `${relativeDir} folder overview`;
}

function autogeneratedNotice() {
  return '<!-- This file is auto-generated by scripts/update-docs.mjs. Manual edits may be overwritten. -->\n';
}

async function generateFunctionMd(dirAbs) {
  const relativeDir = rel(dirAbs);
  const { files, dirs } = await readDirEntries(dirAbs);
  const lines = [];
  const isContentFolder = relativeDir.startsWith('/src/content/');
  if (isContentFolder) {
    const safeTitle = `Docs - ${relativeDir} folder`;
    const quoted = '"' + safeTitle.replace(/"/g, '\\"') + '"';
    lines.push('---');
    lines.push(`title: ${quoted}`);
    lines.push('---');
    lines.push('');
  }
  lines.push(autogeneratedNotice());
  lines.push(`# ${headerTitle(relativeDir)}`);
  lines.push('');
  lines.push(describeDirectory(relativeDir));
  lines.push('');
  if (files.length > 0) {
    lines.push('## Files');
    for (const f of files) {
      lines.push(`- \`${f}\`: ${describeFile(f, relativeDir)}`);
    }
    lines.push('');
  } else {
    lines.push('## Files');
    lines.push('- (none)');
    lines.push('');
  }
  if (dirs.length > 0) {
    lines.push('## Subfolders');
    for (const d of dirs) {
      lines.push(`- \`${d}/\`: Subfolder.`);
    }
    lines.push('');
  }
  lines.push(`Last updated: ${today()}`);
  lines.push('');
  return lines.join('\n');
}

async function writeIfChanged(targetPath, newContent) {
  let current = null;
  try {
    current = await fsp.readFile(targetPath, 'utf8');
  } catch {}
  if (current === newContent) return false;
  await fsp.writeFile(targetPath, newContent, 'utf8');
  return true;
}

async function ensureFunctionMdFor(dirAbs) {
  const content = await generateFunctionMd(dirAbs);
  const target = path.join(dirAbs, 'function.md');
  const changed = await writeIfChanged(target, content);
  return changed ? target : null;
}

async function walkAndGenerate(startDirAbs) {
  const changedFiles = [];
  async function walk(dir) {
    const { dirs } = await readDirEntries(dir);
    const changed = await ensureFunctionMdFor(dir);
    if (changed) changedFiles.push(rel(path.dirname(changed)));
    for (const d of dirs) {
      await walk(path.join(dir, d));
    }
  }
  await walk(startDirAbs);
  return changedFiles;
}

function ensureChangelogHeader(content) {
  const header = '# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n';
  if (!content || content.trim().length === 0) return header;
  // If file starts with just '# Changelog' but misses the sentence, keep as-is
  return content;
}

function findDaySectionBounds(content, dateStr) {
  const dateHeader = `## ${dateStr}`;
  const start = content.indexOf(dateHeader);
  if (start === -1) return { start: -1, end: -1 };
  const rest = content.slice(start + dateHeader.length);
  const nextHeaderRel = rest.search(/\n##\s+\d{4}-\d{2}-\d{2}/);
  const end = nextHeaderRel === -1 ? content.length : start + dateHeader.length + nextHeaderRel;
  return { start, end };
}

function dedupeEntries(entries) {
  const seen = new Set();
  const out = [];
  for (const e of entries) {
    const key = `${e.dir}|${e.reason || ''}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push({ dir: e.dir, reason: e.reason || '' });
  }
  out.sort((a, b) => a.dir.localeCompare(b.dir));
  return out;
}

function buildUpdatedBlockLines(entries) {
  const lines = [];
  lines.push('- Updated: Auto-generated folder docs');
  for (const e of entries) {
    lines.push(`  - \`${e.dir}\`${e.reason ? `: ${e.reason}` : ''}`);
  }
  return lines;
}

function injectOrMergeUpdatedBlock(dayBlock, entries) {
  const UPDATED_LINE = '- Updated: Auto-generated folder docs';
  const lines = dayBlock.split('\n');
  const headerIdx = 0; // dayBlock always starts with the date header
  let insertAt = lines.length; // default append to end of block

  // Search for existing Updated summary line
  let updatedIdx = -1;
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim() === UPDATED_LINE) {
      updatedIdx = i;
      break;
    }
    // Track last top-level bullet for potential insertion grouping
    if (/^\-\s+/.test(line)) insertAt = i + 1;
  }

  if (updatedIdx === -1) {
    // No updated block yet; append a new one
    const newBlock = buildUpdatedBlockLines(entries);
    // Ensure there is a blank line between sections if needed
    if (lines[lines.length - 1].trim().length > 0) lines.push('');
    for (const l of newBlock) lines.push(l);
    return lines.join('\n');
  }

  // Merge into existing updated block
  // Collect existing sub-items under the updated header
  const existingSet = new Set();
  let j = updatedIdx + 1;
  while (j < lines.length) {
    const l = lines[j];
    if (/^\s{2}\-\s+/.test(l)) {
      existingSet.add(l.trim());
      j += 1;
      continue;
    }
    if (/^\-\s+/.test(l) || /^##\s+/.test(l)) break; // next top-level item or next day header
    j += 1;
  }

  const incoming = buildUpdatedBlockLines(entries).slice(1).map(s => s.trim());
  for (const l of incoming) existingSet.add(l);
  const merged = Array.from(existingSet);
  merged.sort((a, b) => a.localeCompare(b));

  // Replace the old sub-block between updatedIdx+1 and j with merged
  const before = lines.slice(0, updatedIdx + 1);
  const after = lines.slice(j);
  return [...before, ...merged.map(s => '  ' + s), ...after].join('\n');
}

async function appendChangelog(entries) {
  if (entries.length === 0) return;
  const changelogPath = path.join(repoRoot, 'changelog.md');
  let existing = '';
  try { existing = await fsp.readFile(changelogPath, 'utf8'); } catch {}
  existing = ensureChangelogHeader(existing);

  const dateStr = today();
  const { start, end } = findDaySectionBounds(existing, dateStr);
  const uniqueEntries = dedupeEntries(entries);
  const dateHeader = `## ${dateStr}`;

  if (start === -1) {
    // Create a fresh day section
    const blockLines = [dateHeader, ...buildUpdatedBlockLines(uniqueEntries)];
    const newContent = existing.trimEnd() + '\n\n' + blockLines.join('\n') + '\n';
    await fsp.writeFile(changelogPath, newContent, 'utf8');
    return;
  }

  const dayBlock = existing.slice(start, end);
  const updatedDayBlock = injectOrMergeUpdatedBlock(dayBlock, uniqueEntries);
  const newContent = existing.slice(0, start) + updatedDayBlock + existing.slice(end);
  await fsp.writeFile(changelogPath, newContent, 'utf8');
}

function parseAllDaySections(content) {
  const re = /\n##\s+(\d{4}-\d{2}-\d{2})/g;
  const sections = [];
  let firstStart = content.indexOf('\n## ');
  if (firstStart === -1) {
    // Maybe file starts with the first section
    if (content.startsWith('## ')) firstStart = 0;
  }
  const indices = [];
  if (firstStart !== -1) indices.push(firstStart);
  let m;
  while ((m = re.exec(content)) !== null) {
    const idx = m.index + 1; // account for the leading \n in the regex
    if (!indices.includes(idx)) indices.push(idx);
  }
  indices.sort((a, b) => a - b);
  for (let i = 0; i < indices.length; i++) {
    const start = indices[i];
    const end = i + 1 < indices.length ? indices[i + 1] : content.length;
    const block = content.slice(start, end);
    const headerMatch = block.match(/^##\s+(\d{4}-\d{2}-\d{2})/);
    if (!headerMatch) continue;
    sections.push({ date: headerMatch[1], start, end });
  }
  return sections;
}

function extractLegacyUpdatedEntriesFromBlock(block) {
  const lines = block.split('\n');
  const legacyRegex = /^-\s+Updated docs for\s+`([^`]+)`(?::\s*(.*))?$/;
  const entries = [];
  for (const l of lines) {
    const m = l.match(legacyRegex);
    if (m) {
      const dir = m[1].trim();
      const reason = (m[2] || '').trim();
      entries.push({ dir, reason });
    }
  }
  return entries;
}

function removeLegacyUpdatedLines(block) {
  const legacyRegex = /^-\s+Updated docs for\s+`[^`]+`(?::\s*.*)?$/;
  return block
    .split('\n')
    .filter(l => !legacyRegex.test(l))
    .join('\n');
}

function extractExistingUpdatedBlockEntries(block) {
  const lines = block.split('\n');
  const UPDATED_LINE = '- Updated: Auto-generated folder docs';
  const entries = [];
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].trim() !== UPDATED_LINE) continue;
    let j = i + 1;
    while (j < lines.length) {
      const l = lines[j];
      const m = l.match(/^\s{2}-\s+`([^`]+)`(?::\s*(.*))?$/);
      if (m) {
        entries.push({ dir: m[1].trim(), reason: (m[2] || '').trim() });
        j += 1;
        continue;
      }
      if (/^\-\s+/.test(l) || /^##\s+/.test(l)) break;
      j += 1;
    }
  }
  return entries;
}

function removeExistingUpdatedBlocks(block) {
  const lines = block.split('\n');
  const UPDATED_LINE = '- Updated: Auto-generated folder docs';
  const out = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim() === UPDATED_LINE) {
      // skip until next top-level bullet or next day header
      let j = i + 1;
      while (j < lines.length) {
        const l = lines[j];
        if (/^\s{2}-\s+/.test(l)) { j += 1; continue; }
        if (/^\-\s+/.test(l) || /^##\s+/.test(l)) break;
        j += 1;
      }
      i = j - 1; // loop will ++
      continue;
    }
    out.push(line);
  }
  return out.join('\n');
}

async function normalizeChangelogFile() {
  const changelogPath = path.join(repoRoot, 'changelog.md');
  let content = '';
  try { content = await fsp.readFile(changelogPath, 'utf8'); } catch {}
  content = ensureChangelogHeader(content);
  const sections = parseAllDaySections(content);
  if (sections.length === 0) {
    await fsp.writeFile(changelogPath, content, 'utf8');
    console.log('Changelog normalized (no sections found).');
    return;
  }
  let updated = content;
  // Process from last to first to keep indices valid when slicing
  for (let idx = sections.length - 1; idx >= 0; idx--) {
    const { start, end } = sections[idx];
    const block = updated.slice(start, end);
    const legacy = extractLegacyUpdatedEntriesFromBlock(block);
    const existing = extractExistingUpdatedBlockEntries(block);
    const combined = dedupeEntries([...existing, ...legacy]);
    if (combined.length === 0) continue;
    // Remove existing updated blocks and legacy lines
    let withoutUpdated = removeExistingUpdatedBlocks(block);
    withoutUpdated = removeLegacyUpdatedLines(withoutUpdated);
    // Ensure a single merged block after the header line
    const pieces = withoutUpdated.split('\n');
    const header = pieces[0];
    const rest = pieces.slice(1).join('\n').trimStart();
    const mergedBlock = injectOrMergeUpdatedBlock(header + '\n' + rest, combined);
    updated = updated.slice(0, start) + mergedBlock + updated.slice(end);
  }
  await fsp.writeFile(changelogPath, updated, 'utf8');
  console.log('Changelog normalized.');
}

function isPathIgnored(absPath) {
  const relPath = rel(absPath);
  if (relPath.includes('/node_modules/') || relPath.includes('/.git/') || relPath.includes('/.turbo/') || relPath.includes('/dist/') || relPath.includes('/build/')) return true;
  const base = path.basename(absPath);
  if (IGNORED_BASENAMES.has(base)) return true;
  if (relPath.endsWith('/' + SCRIPT_RELATIVE_PATH)) return true;
  return false;
}

async function runOnce() {
  const changedDirs = await walkAndGenerate(repoRoot);
  await appendChangelog(changedDirs.map(d => ({ dir: d, reason: 'Generated/updated function.md' })));
  return changedDirs;
}

async function watchAndRun() {
  await runOnce();
  const pending = new Map(); // dir -> reason
  let timer = null;
  function scheduleFlush() {
    if (timer) clearTimeout(timer);
    timer = setTimeout(async () => {
      const dirs = Array.from(pending.keys());
      pending.clear();
      const uniqueDirs = Array.from(new Set(dirs));
      const changedAll = [];
      for (const dirRel of uniqueDirs) {
        const dirAbs = path.join(repoRoot, dirRel);
        try {
          const stat = await fsp.stat(dirAbs).catch(() => null);
          if (stat && stat.isDirectory()) {
            const changed = await ensureFunctionMdFor(dirAbs);
            if (changed) changedAll.push(dirRel);
          }
        } catch {}
      }
      await appendChangelog(changedAll.map(d => ({ dir: d, reason: 'Auto-updated via watcher' })));
    }, 500);
  }

  try {
    const watcher = fs.watch(repoRoot, { recursive: true }, (eventType, filename) => {
      if (!filename) return;
      const abs = path.join(repoRoot, filename);
      if (isPathIgnored(abs)) return;
      const dirRel = '/' + toPosix(path.dirname(filename));
      pending.set(dirRel === '/.' ? '/' : dirRel, 'change');
      scheduleFlush();
    });
    watcher.on('error', () => {});
  } catch (err) {
    // Fallback: simple interval scan of top-level directories
    console.warn('fs.watch recursive not supported; fallback to periodic regeneration.');
    setInterval(runOnce, 5000);
  }
}

async function main() {
  const args = new Set(process.argv.slice(2));
  const watch = args.has('--watch');
  const normalize = args.has('--normalize');

  if (normalize) {
    await normalizeChangelogFile();
    return;
  }
  if (watch) {
    await watchAndRun();
    // keep process alive
    await new Promise(() => {});
  } else {
    const changed = await runOnce();
    if (changed.length === 0) {
      console.log('No documentation changes needed.');
    } else {
      console.log('Updated docs for:', changed.join(', '));
    }
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
